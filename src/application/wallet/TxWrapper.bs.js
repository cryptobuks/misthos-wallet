// Generated by BUCKLESCRIPT VERSION 3.1.5, PLEASE EDIT WITH CARE
'use strict';

var BTC = require("./BTC.bs.js");
var Utils = require("../../utils/Utils.bs.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var BitcoinjsLib = require("bitcoinjs-lib");

function extractInputs(tx) {
  return Belt_Array.map(tx.ins, (function (input) {
                var witness = input.witness;
                var arg = witness.length - 2 | 0;
                var witness$1 = (function (param) {
                      return Belt_Array.slice(param, 1, arg);
                    })(witness);
                return /* record */[/* signatures */witness$1];
              }));
}

function make(hex) {
  var tx = BitcoinjsLib.Transaction.fromHex(hex);
  return /* record */[
          /* tx */tx,
          /* inputs */extractInputs(tx)
        ];
}

function needsSigning(idx, param) {
  var input = Belt_Array.getExn(param[/* inputs */1], idx);
  var sigs = input[/* signatures */0];
  if (sigs.length !== 0) {
    return Belt_Array.someU(sigs, (function (sig_) {
                  return BitcoinjsLib.script.isCanonicalSignature(sig_) === false;
                }));
  } else {
    return true;
  }
}

function sign(idx, keyPair, nCoSigners, redeemScript, witnessValue, witnessScript, param) {
  var tx = param[/* tx */0];
  var witnessBuf = Utils.bufFromHex(witnessScript);
  tx.setInputScript(idx, Utils.bufFromHex(redeemScript));
  var signatureHash = tx.hashForWitnessV0(idx, witnessBuf, BTC.toSatoshisFloat(witnessValue), BitcoinjsLib.Transaction.SIGHASH_ALL);
  var signature = keyPair.sign(signatureHash).toScriptSignature(BitcoinjsLib.Transaction.SIGHASH_ALL);
  var input = Belt_Array.getExn(param[/* inputs */1], idx);
  var sigs = input[/* signatures */0];
  var signatures;
  if (sigs.length !== 0) {
    var match = Belt_Array.reduceU(sigs, /* tuple */[
          -1,
          0
        ], (function (param, sig_) {
            var idx = param[1];
            if (sig_.length() === 0) {
              return /* tuple */[
                      idx,
                      idx + 1 | 0
                    ];
            } else {
              return /* tuple */[
                      param[0],
                      idx + 1 | 0
                    ];
            }
          }));
    var insert = match[0];
    signatures = Belt_Array.mapWithIndexU(sigs, (function (idx, sig_) {
            var match = idx === insert;
            if (match) {
              return signature;
            } else {
              return sig_;
            }
          }));
  } else {
    signatures = Belt_Array.concat(Belt_Array.makeByU(nCoSigners - 1 | 0, (function () {
                return new Buffer(0);
              })), /* array */[signature]);
  }
  tx.setWitness(idx, Belt_Array.concatMany(/* array */[
            /* array */[new Buffer(0)],
            signatures,
            /* array */[witnessBuf]
          ]));
  return /* record */[
          /* tx */tx,
          /* inputs */extractInputs(tx)
        ];
}

var B = 0;

exports.B = B;
exports.extractInputs = extractInputs;
exports.make = make;
exports.needsSigning = needsSigning;
exports.sign = sign;
/* BTC Not a pure module */
