// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var BTC = require("./BTC.bs.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Address = require("./Address.bs.js");
var Json_decode = require("bs-json/src/Json_decode.js");
var Json_encode = require("bs-json/src/Json_encode.js");
var BitcoinjsLib = require("bitcoinjs-lib");
var BitcoindClient = require("./BitcoindClient.bs.js");
var SmartbitClient = require("./SmartbitClient.bs.js");

function encode(param) {
  switch (param) {
    case 0 : 
        return "regtest";
    case 1 : 
        return "testnet";
    case 2 : 
        return "mainnet";
    
  }
}

function decode(raw) {
  var name = Json_decode.string(raw);
  switch (name) {
    case "mainnet" : 
        return /* Mainnet */2;
    case "regtest" : 
        return /* Regtest */0;
    case "testnet" : 
        return /* Testnet */1;
    default:
      return Js_exn.raiseError("Network.decode");
  }
}

function encodeInput(input) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "txId",
                input[/* txId */0]
              ],
              /* :: */[
                /* tuple */[
                  "txOutputN",
                  input[/* txOutputN */1]
                ],
                /* :: */[
                  /* tuple */[
                    "address",
                    input[/* address */2]
                  ],
                  /* :: */[
                    /* tuple */[
                      "value",
                      BTC.encode(input[/* value */3])
                    ],
                    /* :: */[
                      /* tuple */[
                        "nCoSigners",
                        input[/* nCoSigners */4]
                      ],
                      /* :: */[
                        /* tuple */[
                          "nPubKeys",
                          input[/* nPubKeys */5]
                        ],
                        /* :: */[
                          /* tuple */[
                            "coordinates",
                            Address.Coordinates[/* encode */9](input[/* coordinates */6])
                          ],
                          /* [] */0
                        ]
                      ]
                    ]
                  ]
                ]
              ]
            ]);
}

function decodeInput(raw) {
  return /* record */[
          /* txId */Json_decode.field("txId", Json_decode.string, raw),
          /* txOutputN */Json_decode.field("txOutputN", Json_decode.$$int, raw),
          /* address */Json_decode.field("address", Json_decode.string, raw),
          /* value */Json_decode.field("value", BTC.decode, raw),
          /* nCoSigners */Json_decode.field("nCoSigners", Json_decode.$$int, raw),
          /* nPubKeys */Json_decode.field("nPubKeys", Json_decode.$$int, raw),
          /* coordinates */Json_decode.field("coordinates", Address.Coordinates[/* decode */10], raw)
        ];
}

function Make(Client) {
  var network = Client[/* network */0];
  var transactionInputs = function (coordinates, accountKeyChains) {
    var addresses = List.map((function (c) {
            var address = Address.find(c, accountKeyChains);
            return /* tuple */[
                    address[/* address */5],
                    /* tuple */[
                      c,
                      address
                    ]
                  ];
          }), coordinates);
    return Curry._1(Client[/* getUTXOs */1], List.map((function (prim) {
                        return prim[0];
                      }), addresses)).then((function (utxos) {
                  return Promise.resolve(List.map((function (param) {
                                    var address = param[/* address */2];
                                    return /* record */[
                                            /* txId */param[/* txId */0],
                                            /* txOutputN */param[/* txOutputN */1],
                                            /* address */address,
                                            /* value */param[/* amount */3],
                                            /* nCoSigners */List.assoc(address, addresses)[1][/* nCoSigners */0],
                                            /* nPubKeys */List.assoc(address, addresses)[1][/* nPubKeys */1],
                                            /* coordinates */List.assoc(address, addresses)[0]
                                          ];
                                  }), utxos));
                }));
  };
  var broadcastTransaction = Client[/* broadcastTransaction */2];
  return /* module */[
          /* network */network,
          /* transactionInputs */transactionInputs,
          /* broadcastTransaction */broadcastTransaction
        ];
}

var Client = BitcoindClient.make(/* record */[
      /* bitcoindUrl */"http://localhost:18322",
      /* rpcUser */"bitcoin",
      /* rpcPassword */"bitcoin"
    ], BitcoinjsLib.networks.testnet);

var network = Client[/* network */0];

function transactionInputs(coordinates, accountKeyChains) {
  var addresses = List.map((function (c) {
          var address = Address.find(c, accountKeyChains);
          return /* tuple */[
                  address[/* address */5],
                  /* tuple */[
                    c,
                    address
                  ]
                ];
        }), coordinates);
  return Curry._1(Client[/* getUTXOs */1], List.map((function (prim) {
                      return prim[0];
                    }), addresses)).then((function (utxos) {
                return Promise.resolve(List.map((function (param) {
                                  var address = param[/* address */2];
                                  return /* record */[
                                          /* txId */param[/* txId */0],
                                          /* txOutputN */param[/* txOutputN */1],
                                          /* address */address,
                                          /* value */param[/* amount */3],
                                          /* nCoSigners */List.assoc(address, addresses)[1][/* nCoSigners */0],
                                          /* nPubKeys */List.assoc(address, addresses)[1][/* nPubKeys */1],
                                          /* coordinates */List.assoc(address, addresses)[0]
                                        ];
                                }), utxos));
              }));
}

var broadcastTransaction = Client[/* broadcastTransaction */2];

var Regtest = /* module */[
  /* network */network,
  /* transactionInputs */transactionInputs,
  /* broadcastTransaction */broadcastTransaction
];

var Client$1 = SmartbitClient.make(SmartbitClient.testnetConfig, BitcoinjsLib.networks.testnet);

var network$1 = Client$1[/* network */0];

function transactionInputs$1(coordinates, accountKeyChains) {
  var addresses = List.map((function (c) {
          var address = Address.find(c, accountKeyChains);
          return /* tuple */[
                  address[/* address */5],
                  /* tuple */[
                    c,
                    address
                  ]
                ];
        }), coordinates);
  return Curry._1(Client$1[/* getUTXOs */1], List.map((function (prim) {
                      return prim[0];
                    }), addresses)).then((function (utxos) {
                return Promise.resolve(List.map((function (param) {
                                  var address = param[/* address */2];
                                  return /* record */[
                                          /* txId */param[/* txId */0],
                                          /* txOutputN */param[/* txOutputN */1],
                                          /* address */address,
                                          /* value */param[/* amount */3],
                                          /* nCoSigners */List.assoc(address, addresses)[1][/* nCoSigners */0],
                                          /* nPubKeys */List.assoc(address, addresses)[1][/* nPubKeys */1],
                                          /* coordinates */List.assoc(address, addresses)[0]
                                        ];
                                }), utxos));
              }));
}

var broadcastTransaction$1 = Client$1[/* broadcastTransaction */2];

var Testnet = /* module */[
  /* network */network$1,
  /* transactionInputs */transactionInputs$1,
  /* broadcastTransaction */broadcastTransaction$1
];

var Client$2 = SmartbitClient.make(SmartbitClient.mainnetConfig, BitcoinjsLib.networks.bitcoin);

var network$2 = Client$2[/* network */0];

function transactionInputs$2(coordinates, accountKeyChains) {
  var addresses = List.map((function (c) {
          var address = Address.find(c, accountKeyChains);
          return /* tuple */[
                  address[/* address */5],
                  /* tuple */[
                    c,
                    address
                  ]
                ];
        }), coordinates);
  return Curry._1(Client$2[/* getUTXOs */1], List.map((function (prim) {
                      return prim[0];
                    }), addresses)).then((function (utxos) {
                return Promise.resolve(List.map((function (param) {
                                  var address = param[/* address */2];
                                  return /* record */[
                                          /* txId */param[/* txId */0],
                                          /* txOutputN */param[/* txOutputN */1],
                                          /* address */address,
                                          /* value */param[/* amount */3],
                                          /* nCoSigners */List.assoc(address, addresses)[1][/* nCoSigners */0],
                                          /* nPubKeys */List.assoc(address, addresses)[1][/* nPubKeys */1],
                                          /* coordinates */List.assoc(address, addresses)[0]
                                        ];
                                }), utxos));
              }));
}

var broadcastTransaction$2 = Client$2[/* broadcastTransaction */2];

var Mainnet = /* module */[
  /* network */network$2,
  /* transactionInputs */transactionInputs$2,
  /* broadcastTransaction */broadcastTransaction$2
];

function transactionInputs$3(param) {
  switch (param) {
    case 0 : 
        return transactionInputs;
    case 1 : 
        return transactionInputs$1;
    case 2 : 
        return transactionInputs$2;
    
  }
}

function broadcastTransaction$3(param) {
  switch (param) {
    case 0 : 
        return broadcastTransaction;
    case 1 : 
        return broadcastTransaction$1;
    case 2 : 
        return broadcastTransaction$2;
    
  }
}

function bitcoinNetwork(param) {
  switch (param) {
    case 0 : 
        return network;
    case 1 : 
        return network$1;
    case 2 : 
        return network$2;
    
  }
}

var regtestIncomeAddress = "2N8hwP1WmJrFF5QWABn38y63uYLhnJYJYTF";

var testnetIncomeAddress = "2N5a6W8HRpTqMUF7KXfRcv9wvWdWakb89rV";

function incomeAddress(param) {
  if (param !== 0) {
    return testnetIncomeAddress;
  } else {
    return regtestIncomeAddress;
  }
}

exports.encode = encode;
exports.decode = decode;
exports.encodeInput = encodeInput;
exports.decodeInput = decodeInput;
exports.Make = Make;
exports.Regtest = Regtest;
exports.Testnet = Testnet;
exports.Mainnet = Mainnet;
exports.transactionInputs = transactionInputs$3;
exports.broadcastTransaction = broadcastTransaction$3;
exports.bitcoinNetwork = bitcoinNetwork;
exports.regtestIncomeAddress = regtestIncomeAddress;
exports.testnetIncomeAddress = testnetIncomeAddress;
exports.incomeAddress = incomeAddress;
/* Client Not a pure module */
