// Generated by BUCKLESCRIPT VERSION 3.1.4, PLEASE EDIT WITH CARE
'use strict';

var BTC = require("./BTC.bs.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Utils = require("../../utils/Utils.bs.js");
var Address = require("./Address.bs.js");
var Network = require("./Network.bs.js");
var Js_option = require("bs-platform/lib/js/js_option.js");
var Json_decode = require("bs-json/src/Json_decode.js");
var Json_encode = require("bs-json/src/Json_encode.js");
var BitcoinjsLib = require("bitcoinjs-lib");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var NotEnoughFunds = Caml_exceptions.create("PayoutTransaction.NotEnoughFunds");

var NotEnoughSignatures = Caml_exceptions.create("PayoutTransaction.NotEnoughSignatures");

var NoSignaturesForInput = Caml_exceptions.create("PayoutTransaction.NoSignaturesForInput");

function txInputForChangeAddress(txId, _, param) {
  var txHex = param[/* txHex */0];
  return Utils.mapOption((function (address) {
                var tx = BitcoinjsLib.Transaction.fromHex(txHex);
                var match = Js_option.getExn(List.find(Js_option.isSome, List.mapi((function (i, out) {
                                var match = BitcoinjsLib.address.fromOutputScript(out.script, BitcoinjsLib.networks.testnet) === address[/* displayAddress */5];
                                if (match) {
                                  return /* Some */[/* tuple */[
                                            i,
                                            BTC.fromSatoshisFloat(out.value)
                                          ]];
                                } else {
                                  return /* None */0;
                                }
                              }), $$Array.to_list(tx.outs))));
                return /* record */[
                        /* txId */txId,
                        /* txOutputN */match[0],
                        /* address */address[/* displayAddress */5],
                        /* value */match[1],
                        /* nCoSigners */address[/* nCoSigners */0],
                        /* nPubKeys */address[/* nPubKeys */1],
                        /* coordinates */address[/* coordinates */2]
                      ];
              }), param[/* changeAddress */3]);
}

function encode(payout) {
  return Json_encode.object_(/* :: */[
              /* tuple */[
                "txHex",
                payout[/* txHex */0]
              ],
              /* :: */[
                /* tuple */[
                  "usedInputs",
                  Json_encode.array(Network.encodeInput, payout[/* usedInputs */1])
                ],
                /* :: */[
                  /* tuple */[
                    "misthosFeeAddress",
                    payout[/* misthosFeeAddress */2]
                  ],
                  /* :: */[
                    /* tuple */[
                      "changeAddress",
                      Json_encode.nullable(Address.encode, payout[/* changeAddress */3])
                    ],
                    /* [] */0
                  ]
                ]
              ]
            ]);
}

function decode(raw) {
  return /* record */[
          /* txHex */Json_decode.field("txHex", Json_decode.string, raw),
          /* usedInputs */Json_decode.field("usedInputs", (function (param) {
                  return Json_decode.array(Network.decodeInput, param);
                }), raw),
          /* misthosFeeAddress */Json_decode.field("misthosFeeAddress", Json_decode.string, raw),
          /* changeAddress */Json_decode.field("changeAddress", (function (param) {
                  return Json_decode.optional(Address.decode, param);
                }), raw)
        ];
}

var misthosFeePercent = 1.49;

exports.NotEnoughFunds = NotEnoughFunds;
exports.NotEnoughSignatures = NotEnoughSignatures;
exports.NoSignaturesForInput = NoSignaturesForInput;
exports.misthosFeePercent = misthosFeePercent;
exports.txInputForChangeAddress = txInputForChangeAddress;
exports.encode = encode;
exports.decode = decode;
/* BTC Not a pure module */
