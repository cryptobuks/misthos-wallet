// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Event = require("../application/events/Event.bs.js");
var Utils = require("../utils/Utils.bs.js");
var Session = require("../application/Session.bs.js");
var Venture = require("../application/Venture.bs.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var EventLog = require("../application/events/EventLog.bs.js");
var Json_decode = require("bs-json/src/Json_decode.js");
var WorkerUtils = require("./WorkerUtils.bs.js");
var PrimitiveTypes = require("../application/PrimitiveTypes.bs.js");
var SmartbitClient = require("../application/wallet/SmartbitClient.bs.js");
var WorkerLocalStorage = require("./WorkerLocalStorage.bs.js");

(( self.localStorage = require("./fakeLocalStorage").localStorage ));

(( self.window = { localStorage: self.localStorage , location: { origin: self.origin } } ));

function logMessage(msg) {
  console.log("[Income Worker] - " + msg);
  return /* () */0;
}

var testnetApiEndpoint = "https://testnet-api.smartbit.com.au/v1/blockchain/address";

function decodeResponse(raw) {
  return Json_decode.withDefault(/* [] */0, (function (param) {
                return Json_decode.field("address", (function (address) {
                              return $$Array.to_list(Json_decode.field("transactions", (function (param) {
                                                return Json_decode.array(SmartbitClient.decodeTransaction, param);
                                              }), address));
                            }), param);
              }), raw);
}

function fetchTransactionsForAddress(address) {
  return fetch(testnetApiEndpoint + ("/" + address)).then((function (res) {
                if (res.status === 200) {
                  return res.json().then((function (json) {
                                return Promise.resolve(decodeResponse(json));
                              }));
                } else {
                  return Promise.resolve(/* [] */0);
                }
              }));
}

function scanTransactions(param) {
  var txIds = param[1];
  var addresses = param[0];
  return Promise.all($$Array.of_list(List.map((function (address) {
                          return fetchTransactionsForAddress(address).then((function (txs) {
                                        return Promise.resolve(List.filter((function (tx) {
                                                            return List.mem(tx[/* txId */0], txIds) === false;
                                                          }))(List.filter((function (tx) {
                                                                return List.exists((function (o) {
                                                                              return o[/* address */0] === address;
                                                                            }), tx[/* outputs */1]);
                                                              }))(txs)));
                                      }));
                        }), addresses))).then((function (txs) {
                return Promise.resolve(/* tuple */[
                            addresses,
                            List.flatten($$Array.to_list(txs))
                          ]);
              }));
}

var findAddressesAndTxIds = Curry._2(EventLog.reduce, (function (param, param$1) {
        var $$event = param$1[/* event */0];
        var txIds = param[1];
        var addresses = param[0];
        switch ($$event.tag | 0) {
          case 32 : 
              return /* tuple */[
                      /* :: */[
                        $$event[0][/* address */1],
                        addresses
                      ],
                      txIds
                    ];
          case 33 : 
              return /* tuple */[
                      addresses,
                      /* :: */[
                        $$event[0][/* txId */1],
                        txIds
                      ]
                    ];
          default:
            return /* tuple */[
                    addresses,
                    txIds
                  ];
        }
      }), /* tuple */[
      /* [] */0,
      /* [] */0
    ]);

function detectIncomeFromTransaction(addresses) {
  return (function (param) {
      return List.map((function (tx) {
                    return List.map((function (out) {
                                  return Event.IncomeDetected[/* encode */1](Event.IncomeDetected[/* make */0](out[/* address */0], tx[/* txId */0], out[/* amount */1]));
                                }), List.filter((function (o) {
                                        return List.mem(o[/* address */0], addresses);
                                      }))(tx[/* outputs */1]));
                  }), param);
    });
}

function detectIncomeFromVenture(ventureId) {
  logMessage("Detecting income for venture '" + (PrimitiveTypes.VentureId[/* toString */0](ventureId) + "'"));
  return WorkerUtils.loadVenture(ventureId).then((function (eventLog) {
                  return scanTransactions(Curry._1(findAddressesAndTxIds, eventLog));
                })).then((function (param) {
                return Promise.resolve((List.map((function (events) {
                                    postMessage(/* TransactionDetected */Block.__(14, [
                                            ventureId,
                                            events
                                          ]));
                                    return /* () */0;
                                  }), detectIncomeFromTransaction(param[0])(param[1])), /* () */0));
              }));
}

function detectIncomeFromAll() {
  return Session.getCurrentSession(/* () */0).then((function (param) {
                if (typeof param === "number") {
                  return Promise.resolve(/* () */0);
                } else {
                  return Venture.Index[/* load */0](/* () */0).then((function (index) {
                                return Promise.resolve(List.iter((function (param) {
                                                  detectIncomeFromVenture(param[/* id */0]);
                                                  return /* () */0;
                                                }), index));
                              }));
                }
              }));
}

function handleMsg(param) {
  logMessage("Handling 'UpdateSession'");
  WorkerLocalStorage.setBlockstackItems(param[0]);
  detectIncomeFromAll(/* () */0);
  return setInterval((function () {
                detectIncomeFromAll(/* () */0);
                return /* () */0;
              }), 10000);
}

var intervalId = [/* None */0];

self.onmessage = (function (msg) {
    var newIntervalid = handleMsg(msg.data);
    Utils.mapOption((function (id) {
            if (Caml_obj.caml_notequal(newIntervalid, id)) {
              clearInterval(id);
              return /* () */0;
            } else {
              return 0;
            }
          }), intervalId[0]);
    intervalId[0] = /* Some */[newIntervalid];
    return /* () */0;
  });

var Message = 0;

var tenSecondsInMilliseconds = 10000;

var syncInterval = 10000;

exports.Message = Message;
exports.logMessage = logMessage;
exports.testnetApiEndpoint = testnetApiEndpoint;
exports.decodeResponse = decodeResponse;
exports.fetchTransactionsForAddress = fetchTransactionsForAddress;
exports.scanTransactions = scanTransactions;
exports.findAddressesAndTxIds = findAddressesAndTxIds;
exports.detectIncomeFromTransaction = detectIncomeFromTransaction;
exports.detectIncomeFromVenture = detectIncomeFromVenture;
exports.detectIncomeFromAll = detectIncomeFromAll;
exports.tenSecondsInMilliseconds = tenSecondsInMilliseconds;
exports.syncInterval = syncInterval;
exports.handleMsg = handleMsg;
exports.intervalId = intervalId;
/*  Not a pure module */
