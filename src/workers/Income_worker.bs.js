// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Json_decode = require("bs-json/src/Json_decode.js");
var SmartbitClient = require("../application/wallet/SmartbitClient.bs.js");
var IncomeWorkerMessage = require("./IncomeWorkerMessage.bs.js");

function postMessage$1(receive) {
  postMessage(IncomeWorkerMessage.encodeReceive(receive));
  return /* () */0;
}

function logMessage(msg) {
  console.log("[Income Worker] - " + msg);
  return /* () */0;
}

var interval = [/* None */0];

var testnetApiEndpoint = "https://testnet-api.smartbit.com.au/v1/blockchain/address";

function decodeResponse(raw) {
  return Json_decode.withDefault(/* [] */0, (function (param) {
                return Json_decode.field("address", (function (address) {
                              return $$Array.to_list(Json_decode.field("transactions", (function (param) {
                                                return Json_decode.array(SmartbitClient.decodeTransaction, param);
                                              }), address));
                            }), param);
              }), raw);
}

function fetchTransactionsForAddress(address) {
  return fetch(testnetApiEndpoint + ("/" + address)).then((function (res) {
                if (res.status === 200) {
                  return res.json().then((function (json) {
                                return Promise.resolve(decodeResponse(json));
                              }));
                } else {
                  return Promise.resolve(/* [] */0);
                }
              }));
}

function scanTransactions(addresses, txIds) {
  return List.iter((function (address) {
                fetchTransactionsForAddress(address).then((function (txs) {
                        var newTransactions = List.filter((function (tx) {
                                  return +(List.mem(tx[/* txId */0], txIds) === /* false */0);
                                }))(List.filter((function (tx) {
                                      return List.exists((function (o) {
                                                    return +(o[/* address */0] === address);
                                                  }), tx[/* outputs */1]);
                                    }))(txs));
                        return Promise.resolve(List.length(newTransactions) > 0 ? (postMessage(IncomeWorkerMessage.encodeReceive(/* NewTransactionsDetected */[newTransactions])), /* () */0) : 0);
                      }));
                return /* () */0;
              }), addresses);
}

function handleMsg(msg) {
  logMessage("Received message '" + (IncomeWorkerMessage.msgType(msg) + "'"));
  var match = interval[0];
  if (match) {
    clearInterval(match[0]);
  }
  if (msg) {
    var txIds = msg[1];
    var exposedAddresses = msg[0];
    logMessage("Scanning transactions");
    scanTransactions(exposedAddresses, txIds);
    interval[0] = /* Some */[setInterval((function () {
              return scanTransactions(exposedAddresses, txIds);
            }), 10000)];
    return /* () */0;
  } else {
    var match$1 = interval[0];
    if (match$1) {
      clearInterval(match$1[0]);
      return /* () */0;
    } else {
      return /* () */0;
    }
  }
}

self.onmessage = (function (msg) {
    return handleMsg(msg.data);
  });

var Message = 0;

var tenSecondsInMilliseconds = 10000;

var syncInterval = 10000;

exports.Message = Message;
exports.postMessage = postMessage$1;
exports.logMessage = logMessage;
exports.tenSecondsInMilliseconds = tenSecondsInMilliseconds;
exports.syncInterval = syncInterval;
exports.interval = interval;
exports.testnetApiEndpoint = testnetApiEndpoint;
exports.decodeResponse = decodeResponse;
exports.fetchTransactionsForAddress = fetchTransactionsForAddress;
exports.scanTransactions = scanTransactions;
exports.handleMsg = handleMsg;
/*  Not a pure module */
