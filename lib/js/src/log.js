// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

var Json            = require("bs-json/lib/js/src/Json.js");
var List            = require("bs-platform/lib/js/list.js");
var Curry           = require("bs-platform/lib/js/curry.js");
var Utils           = require("./utils.js");
var Json_encode     = require("bs-json/lib/js/src/Json_encode.js");
var BitcoinjsLib    = require("bitcoinjs-lib");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var Illegal = Caml_exceptions.create("Log.Illegal");

function Make(funarg) {
  var make = function (vState) {
    return /* tuple */[
            vState,
            /* [] */0
          ];
  };
  var createItem = function (issuerKeyPair, payload) {
    var encodedPayload = Curry._1(funarg[/* encode */1], payload);
    var hashBuffer = BitcoinjsLib.crypto.sha256(encodedPayload);
    var hash = Utils.toHex(hashBuffer);
    var issuerPubKey = Utils.publicKeyFromKeyPair(issuerKeyPair);
    var signature_001 = issuerKeyPair.sign(hashBuffer);
    var signature = /* tuple */[
      issuerPubKey,
      signature_001
    ];
    return /* record */[
            /* payload */payload,
            /* type_ */Curry._1(funarg[/* getType */0], payload),
            /* encodedPayload */encodedPayload,
            /* hash */hash,
            /* signature */signature
          ];
  };
  var createEntry = function (lastHash, keyPair, item) {
    var logHashBuffer = BitcoinjsLib.crypto.sha256(lastHash + item[/* hash */3]);
    var logHash = Utils.toHex(logHashBuffer);
    var signature = keyPair.sign(logHashBuffer);
    return /* record */[
            /* item */item,
            /* logHash */logHash,
            /* witnesses : :: */[
              /* tuple */[
                Utils.publicKeyFromKeyPair(keyPair),
                signature
              ],
              /* [] */0
            ]
          ];
  };
  var append = function (payload, keyPair, param) {
    var log = param[1];
    var vState = param[0];
    var pubKey = Utils.publicKeyFromKeyPair(keyPair);
    var canSign = Curry._3(funarg[/* canKeySignItem */4], vState, payload, pubKey);
    var canWitness = Curry._3(funarg[/* canKeyWitnessItem */3], vState, payload, pubKey);
    var match = Curry._2(funarg[/* validate */5], vState, payload);
    if (canSign && canWitness && match[0]) {
      var newItem = createItem(keyPair, payload);
      var newLog;
      if (log) {
        var e = log[0];
        newLog = /* :: */[
          createEntry(e[/* logHash */1], keyPair, newItem),
          /* :: */[
            e,
            log[1]
          ]
        ];
      } else {
        newLog = /* :: */[
          createEntry("", keyPair, newItem),
          /* [] */0
        ];
      }
      return /* tuple */[
              match[1],
              newLog
            ];
    } else {
      throw Illegal;
    }
  };
  var reduce = function (reducer, start, param) {
    return List.fold_left(reducer, start, List.rev_map((function (entry) {
                      return entry[/* item */0][/* payload */0];
                    }), param[1]));
  };
  var merge = function (log, _) {
    return log;
  };
  var validate = function (validatorState, log) {
    return /* tuple */[
            validatorState,
            log
          ];
  };
  var decode = function () {
    return /* [] */0;
  };
  var ecSig = function (ecSig$1) {
    return Utils.toHex(ecSig$1.toDER());
  };
  var signature = function (signature$1) {
    return Json_encode.pair((function (prim) {
                  return prim;
                }), ecSig, signature$1);
  };
  var item = function (item$1) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "type",
                  item$1[/* type_ */1]
                ],
                /* :: */[
                  /* tuple */[
                    "payload",
                    item$1[/* encodedPayload */2]
                  ],
                  /* :: */[
                    /* tuple */[
                      "hash",
                      item$1[/* hash */3]
                    ],
                    /* :: */[
                      /* tuple */[
                        "sig",
                        Json_encode.pair((function (prim) {
                                return prim;
                              }), ecSig, item$1[/* signature */4])
                      ],
                      /* [] */0
                    ]
                  ]
                ]
              ]);
  };
  var entry = function (entry$1) {
    return Json_encode.object_(/* :: */[
                /* tuple */[
                  "item",
                  item(entry$1[/* item */0])
                ],
                /* :: */[
                  /* tuple */[
                    "logHash",
                    entry$1[/* logHash */1]
                  ],
                  /* :: */[
                    /* tuple */[
                      "witnesses",
                      Json_encode.list(signature, entry$1[/* witnesses */2])
                    ],
                    /* [] */0
                  ]
                ]
              ]);
  };
  var encode = function (param) {
    return Json.stringify(Json_encode.list(entry, param[1]));
  };
  return [
          make,
          validate,
          append,
          reduce,
          merge,
          encode,
          decode
        ];
}

exports.Illegal = Illegal;
exports.Make    = Make;
/* Utils Not a pure module */
